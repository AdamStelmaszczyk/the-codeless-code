Date: 2013-04-21
Number: 90
Title: Not A Number
Credits: Thanks to Christopher Lynnes and Eric Winter for the idea.
Geekiness: 3
Topics: philosophy, null object pattern, NaN, numbers, zero, Javascript
Names: Kaimu, Spider Clan
Skip: 0
Illus.0.src: naan.jpg
Illus.0.title: Apparently it's made with lots of naan-fat butter.

Master [[Kaimu]] was approached by a monk of the [[Spider Clan]],
who said:
"In Javascript, zero is divided by zero, the result is
<tt>NaN</tt>: not-a-number.  Yet <tt>typeof(NaN)</tt> is
<tt>number</tt>.  What sense may be found in such a language,
where a value is both something and not-something?"

Kaimu gave the monk a coin, saying, "On the Road of White Nettles
lives a baker who sells flatbreads as round as the most perfect zero.
Purchase as many as you are able and bring them to me."

The monk did as he was told.  When the baker received his payment
he threw the monk bodily out of the shop and flung
the coin after him.

"Counterfeit money," said the baker.

- - -

<div style="color:#666">
Upon returning to the temple, the monk found one of the
gardeners, switched clothes with him, and sent the gardener
to see master Kaimu alone.

Kaimu was amused by the obvious deception.  "Monk!" he said.
"Where is my bread?"

As instructed by the monk, the non-monk replied, "Divided
equally among all who helped me carry it."

Kaimu was satisfied.
</div>

== Qi's commentary

Worthless money, imitation monk, fictitious bread,
<span style="color:#666">false ending</span>.


== Qi's poem

Kaimu met an ancient soldier: a lost and desperate man, //
for he could not remember his own name. //
The master gave him coin, saying, "This to you from Kaimu." //
The soldier cried with joy, "Then I must be Not Kaimu!"


###END

Just out of curiosity.

It doesn't seem very logical that typeof NaN is number. Just
like NaN === NaN or NaN == NaN returning false, by the
way. Is this one of the peculiarities of javascript, or
would there be a reason for this?

Edit: thanks for your answers. It's not an easy thing to get
ones head around though. Reading answers and the wiki I
understood more, but still, a sentence like

A comparison with a NaN always returns an unordered result
even when comparing with itself. The comparison predicates
are either signaling or non-signaling, the signaling
versions signal an invalid exception for such
comparisons. The equality and inequality predicates are
non-signaling so x = x returning false can be used to test
if x is a quiet NaN.

Even more fun (but understandable coming to think of it,
isNaN returns a boolean): isNaN(parseInt('nodice')) ===
isNaN(parseInt('someOtherNaN')) === true; – KooiInc May 10
'10 at 9:48



There are three kinds of operation which return NaN:

Operations with a NaN as at least one operand

Indeterminate forms

The divisions 0/0, ∞/∞, ∞/−∞, −∞/∞, and −∞/−∞
The multiplications 0×∞ and 0×−∞
The power 1^∞
The additions ∞ + (−∞), (−∞) + ∞ and equivalent subtractions.
Real operations with complex results:

The square root of a negative number
The logarithm of a negative number
The tangent of an odd multiple of 90 degrees (or π/2 radians)
The inverse sine or cosine of a number which is less than −1 or greater than +1.
